  // Auto-increment from AI models with improved typing animation
  useEffect(() => {
    if (!activeModel) {
      setIsAIWriting(false);
      return;
    }
    
    setIsAIWriting(true);
    
    // Set up an interval to animate the code typing
    const interval = setInterval(() => {
      // Add to code lines based on model speed
      const aiIncrement = activeModel.autoCodePerSecond / 10;
      setCodeLines(prev => prev + aiIncrement);
      
      // Make typing speed much more visible by increasing characters typed per tick
      // This makes the AI writing more noticeable to the player
      const typingSpeed = Math.max(5, Math.floor(aiIncrement / 0.5));
      typeNextCharacters(typingSpeed);
      
      updateAICodeShare();
    }, 50); // Faster interval for smoother animation
    
    return () => {
      clearInterval(interval);
      setIsAIWriting(false);
    };
  }, [activeModel, visibleCodeSample]);

  // Timer for money generation
  useEffect(() => {
    const timer = setInterval(() => {
      setMoneyTimer(prev => {
        if (prev <= 0) {
          // Use the ref to get the latest codeLines value
          const currentCodeLines = codeLinesRef.current;
          setMoney(prevMoney => {
            return prevMoney + Math.floor(currentCodeLines);
          });
          return 5;
        }
        return prev - 1;
      });
    }, 1000);
    
    return () => clearInterval(timer);
  }, []);

  // Process incoming tasks
  useEffect(() => {
    // Generate a new task every 15 seconds if there are unlockedTasks
    const taskInterval = setInterval(() => {
      if (unlockedTasks.length > 0 && activeTab === "management") {
        const randomTaskType = unlockedTasks[Math.floor(Math.random() * unlockedTasks.length)];
        const reward = Math.floor(
          randomTaskType.minReward + 
          Math.random() * (randomTaskType.maxReward - randomTaskType.minReward)
        );
        
        const newTask = {
          id: `task-${Date.now()}`,
          type: randomTaskType.id,
          name: `${randomTaskType.name} Task`,
          description: `A ${randomTaskType.name.toLowerCase()} task that needs to be completed.`,
          reward,
          complexity: randomTaskType.complexity,
          timeToComplete: randomTaskType.timeRequired,
          expiresIn: 300, // 5 minutes in seconds
          status: "available"
        };
        
        setIncomingTasks(prev => [...prev, newTask]);
      }
    }, 15000);
    
    // Update task timers and progress every second
    const progressInterval = setInterval(() => {
      // Update assignment progress
      setActiveAssignments(prev => 
        prev.map(assignment => {
          const agentType = getAgentType(assignment.agent.type);
          
          if (assignment.status === "in-progress") {
            // Calculate progress increment based on agent efficiency
            const newProgress = assignment.progress + 
              (agentType.efficiency / assignment.task.timeToComplete);
            
            if (newProgress >= 1) {
              // Task completed automatically if agent has sufficient autonomy
              setMoney(m => m + assignment.task.reward);
              setCompletedTasks(ct => ct + 1);
              
              // Release the agent
              setOwnedAgents(agents => 
                agents.map(a => 
                  a.id === assignment.agent.id 
                    ? { ...a, currentTasks: a.currentTasks - 1 } 
                    : a
                )
              );
              
              return { ...assignment, progress: 1, status: "completed" };
            }
            
            return { ...assignment, progress: newProgress };
          }
          
          // Auto-complete verified tasks for agents with autonomy > 0.3
          if (assignment.status === "verified" && agentType.autonomy > 0.3) {
            const newProgress = assignment.progress + 
              (agentType.efficiency / assignment.task.timeToComplete);
              
            if (newProgress >= 1) {
              // Complete the task
              setMoney(m => m + assignment.task.reward);
              setCompletedTasks(ct => ct + 1);
              
              // Release the agent
              setOwnedAgents(agents => 
                agents.map(a => 
                  a.id === assignment.agent.id 
                    ? { ...a, currentTasks: a.currentTasks - 1 } 
                    : a
                )
              );
              
              return { ...assignment, progress: 1, status: "completed" };
            }
            
            return { ...assignment, progress: newProgress };
          }
          
          return assignment;
        })
      );

      // Update task expiration timers
      setIncomingTasks(prev => 
        prev.filter(task => {
          const newExpiresIn = task.expiresIn - 1;
          if (newExpiresIn <= 0) return false;
          task.expiresIn = newExpiresIn;
          return true;
        })
      );
      
      // Remove completed tasks after a while
      setActiveAssignments(prev => 
        prev.filter(assignment => {
          if (assignment.status === "completed") {
            // Keep completed tasks visible for 5 seconds
            if (!assignment.completedAt) {
              assignment.completedAt = Date.now();
              return true;
            }
            
            // Remove after 5 seconds
            return (Date.now() - assignment.completedAt) < 5000;
          }
          return true;
        })
      );
    }, 1000);
    
    return () => {
      clearInterval(taskInterval);
      clearInterval(progressInterval);
    };
  }, [activeTab]);

  // Update highlighted text when code changes
  const updateHighlightedText = (text) => {
    const highlighted = syntaxHighlight(
      text, 
      CODE_SAMPLES[visibleCodeSample].language
    );
    setHighlightedText(highlighted);
  };

  // Function to update AI code share percentage
  const updateAICodeShare = () => {
    if (!activeModel) {
      setAiCodeShare(0);
      return;
    }
    
    // Don't update if in observation mode
    if (observationMode) return;
    
    // Calculate AI code share based on active model and total code
    const manualCode = incrementFactor * 10; // Rough estimate of manual capacity
    const aiCode = activeModel.autoCodePerSecond;
    const percentage = (aiCode / (aiCode + manualCode)) * 100;
    setAiCodeShare(Math.min(percentage, 99.99));
  };

  // Function to type next characters in the code sample
  const typeNextCharacters = (count) => {
    const currentSample = CODE_SAMPLES[visibleCodeSample];
    const sampleCode = currentSample.code;
    
    if (typingPosition >= sampleCode.length) {
      // Move to next code sample when current one is complete
      const nextSample = (visibleCodeSample + 1) % CODE_SAMPLES.length;
      setVisibleCodeSample(nextSample);
      setTypingPosition(0);
      setCurrentCodeText('');
      updateHighlightedText('');
      return;
    }
    
    // Type next characters
    const nextPosition = Math.min(typingPosition + count, sampleCode.length);
    const newText = sampleCode.substring(0, nextPosition);
    setCurrentCodeText(newText);
    updateHighlightedText(newText);
    setTypingPosition(nextPosition);
  };import React, { useState, useEffect, useRef } from 'react';
import { Terminal, Code, Users, PieChart, Zap, Cpu, Briefcase, CheckCircle } from 'lucide-react';

// Code samples with language-specific syntax highlighting classes
const CODE_SAMPLES = [
  {
    language: "JavaScript",
    filename: "app.js",
    code: `// Modern JavaScript application
import { useState, useEffect } from 'react';

// Simple Todo application
function TodoApp() {
  const [todos, setTodos] = useState([]);
  const [inputValue, setInputValue] = useState('');
  
  // Load todos from localStorage on mount
  useEffect(() => {
    const savedTodos = localStorage.getItem('todos');
    if (savedTodos) {
      setTodos(JSON.parse(savedTodos));
    }
  }, []);
  
  // Save todos to localStorage when they change
  useEffect(() => {
    localStorage.setItem('todos', JSON.stringify(todos));
  }, [todos]);
  
  const handleSubmit = (e) => {
    e.preventDefault();
    if (!inputValue.trim()) return;
    
    const newTodo = {
      id: Date.now(),
      text: inputValue,
      completed: false
    };
    
    setTodos([...todos, newTodo]);
    setInputValue('');
  };
  
  const toggleTodo = (id) => {
    setTodos(todos.map(todo => 
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };
  
  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };
  
  return (
    <div className="todo-app">
      <h1>Todo List</h1>
      
      <form onSubmit={handleSubmit}>
        <input
          type="text"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder="Add a new task"
        />
        <button type="submit">Add</button>
      </form>
      
      <ul className="todo-list">
        {todos.map(todo => (
          <li key={todo.id} className={todo.completed ? 'completed' : ''}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            />
            <span>{todo.text}</span>
            <button onClick={() => deleteTodo(todo.id)}>Delete</button>
          </li>
        ))}
      </ul>
      
      <div className="todo-count">
        {todos.filter(todo => !todo.completed).length} items left
      </div>
    </div>
  );
}`
  },
  {
    language: "Python",
    filename: "data_analysis.py",
    code: `# Data analysis script in Python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler

# Generate some sample data
np.random.seed(42)
n_samples = 1000

# Create customer data with 2 clear segments
segment1 = np.random.normal(loc=[5, 10], scale=[1, 1.5], size=(n_samples//2, 2))
segment2 = np.random.normal(loc=[15, 5], scale=[1.5, 1], size=(n_samples//2, 2))

data = np.vstack([segment1, segment2])
df = pd.DataFrame(data, columns=['purchase_frequency', 'avg_order_value'])

# Add some noise features
df['visit_count'] = np.random.normal(loc=10, scale=5, size=n_samples)
df['days_since_last_purchase'] = np.random.exponential(scale=30, size=n_samples)

# Scale the features
scaler = StandardScaler()
features = ['purchase_frequency', 'avg_order_value', 
            'visit_count', 'days_since_last_purchase']
X_scaled = scaler.fit_transform(df[features])

# Find optimal number of clusters using the elbow method
inertia = []
for k in range(1, 11):
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(X_scaled)
    inertia.append(kmeans.inertia_)

# Plot the elbow curve
plt.figure(figsize=(10, 6))
plt.plot(range(1, 11), inertia, marker='o')
plt.title('Elbow Method for Optimal k')
plt.xlabel('Number of clusters')
plt.ylabel('Inertia')
plt.xticks(range(1, 11))
plt.grid(True, linestyle='--', alpha=0.7)

# Apply K-means with the optimal number of clusters (k=2 in this case)
kmeans = KMeans(n_clusters=2, random_state=42)
df['cluster'] = kmeans.fit_predict(X_scaled)

# Visualize the clusters
plt.figure(figsize=(12, 8))
plt.scatter(df['purchase_frequency'], df['avg_order_value'], 
            c=df['cluster'], cmap='viridis', alpha=0.8, s=50)

# Plot cluster centers
centers = scaler.inverse_transform(kmeans.cluster_centers_)[:, :2]
plt.scatter(centers[:, 0], centers[:, 1], c='red', s=200, alpha=0.8, marker='X')

plt.title('Customer Segmentation')
plt.xlabel('Purchase Frequency')
plt.ylabel('Average Order Value')
plt.grid(True, linestyle='--', alpha=0.7)

# Calculate cluster statistics
cluster_stats = df.groupby('cluster').agg({
    'purchase_frequency': ['mean', 'std'],
    'avg_order_value': ['mean', 'std'],
    'visit_count': ['mean', 'std'],
    'days_since_last_purchase': ['mean', 'std']
})

print("Cluster Statistics:")
print(cluster_stats)

# Output recommendations based on segments
print("\nMarketing Recommendations:")
print("Segment 1: High-frequency, high-value customers")
print("  - Focus on retention and loyalty programs")
print("  - Offer premium products and services")

print("\nSegment 2: Low-frequency, low-value customers")
print("  - Focus on engagement and activation")
print("  - Offer incentives to increase purchase frequency")`
  },
  {
    language: "Rust",
    filename: "game_logic.rs",
    code: `// Simple game logic in Rust
use std::collections::HashMap;
use std::fmt;
use rand::Rng;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
enum ItemType {
    Weapon,
    Armor,
    Potion,
    Scroll,
    Gem,
}

#[derive(Debug, Clone)]
struct Item {
    id: u32,
    name: String,
    item_type: ItemType,
    level: u32,
    value: u32,
    properties: HashMap<String, i32>,
}

impl Item {
    fn new(id: u32, name: &str, item_type: ItemType, level: u32) -> Self {
        let value = match item_type {
            ItemType::Weapon => level * 10,
            ItemType::Armor => level * 8,
            ItemType::Potion => level * 5,
            ItemType::Scroll => level * 15,
            ItemType::Gem => level * 25,
        };
        
        Item {
            id,
            name: name.to_string(),
            item_type,
            level,
            value,
            properties: HashMap::new(),
        }
    }
    
    fn add_property(&mut self, name: &str, value: i32) -> &mut Self {
        self.properties.insert(name.to_string(), value);
        self
    }
}`
  },
  {
    language: "C++",
    filename: "particle_system.cpp",
    code: `// C++ Particle System Simulation
#include <iostream>
#include <vector>
#include <cmath>
#include <random>
#include <algorithm>
#include <chrono>
#include <thread>

struct Vector2 {
    float x, y;
    
    Vector2(float x = 0.0f, float y = 0.0f) : x(x), y(y) {}
    
    Vector2 operator+(const Vector2& v) const { 
        return Vector2(x + v.x, y + v.y); 
    }
    
    Vector2 operator-(const Vector2& v) const { 
        return Vector2(x - v.x, y - v.y); 
    }
    
    Vector2 operator*(float s) const { 
        return Vector2(x * s, y * s); 
    }
    
    float length() const { 
        return std::sqrt(x*x + y*y); 
    }
    
    Vector2 normalized() const {
        float len = length();
        if (len > 0.0001f) {
            return Vector2(x / len, y / len);
        }
        return *this;
    }
};

struct Color {
    float r, g, b, a;
    
    Color(float r = 1.0f, float g = 1.0f, float b = 1.0f, float a = 1.0f) 
        : r(r), g(g), b(b), a(a) {}
    
    Color lerp(const Color& other, float t) const {
        return Color(
            r + (other.r - r) * t,
            g + (other.g - g) * t,
            b + (other.b - b) * t,
            a + (other.a - a) * t
        );
    }
}`
  },
  {
    language: "Go",
    filename: "server.go",
    code: `// Simple web server in Go
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"math/rand"
	"net/http"
	"strconv"
	"sync"
	"time"
)

// Task represents a to-do item
type Task struct {
	ID        int       \`json:"id"\`
	Title     string    \`json:"title"\`
	Completed bool      \`json:"completed"\`
	CreatedAt time.Time \`json:"created_at"\`
}

// TaskManager handles task operations
type TaskManager struct {
	tasks  map[int]Task
	nextID int
	mutex  sync.RWMutex
}

// NewTaskManager creates a new task manager
func NewTaskManager() *TaskManager {
	return &TaskManager{
		tasks:  make(map[int]Task),
		nextID: 1,
	}
}

// CreateTask adds a new task
func (tm *TaskManager) CreateTask(title string) Task {
	tm.mutex.Lock()
	defer tm.mutex.Unlock()

	task := Task{
		ID:        tm.nextID,
		Title:     title,
		Completed: false,
		CreatedAt: time.Now(),
	}

	tm.tasks[tm.nextID] = task
	tm.nextID++

	return task
}`
  },
  {
    language: "Swift",
    filename: "weather_app.swift",
    code: `// Swift Weather App
import SwiftUI

// MARK: - Models

struct WeatherData: Identifiable, Codable {
    let id: UUID
    let city: String
    let temperature: Double
    let condition: WeatherCondition
    let humidity: Int
    let windSpeed: Double
    let date: Date
    
    init(city: String, temperature: Double, condition: WeatherCondition, humidity: Int, windSpeed: Double, date: Date = Date()) {
        self.id = UUID()
        self.city = city
        self.temperature = temperature
        self.condition = condition
        self.humidity = humidity
        self.windSpeed = windSpeed
        self.date = date
    }
}

enum WeatherCondition: String, Codable, CaseIterable {
    case sunny
    case cloudy
    case rainy
    case stormy
    case snowy
    
    var emoji: String {
        switch self {
        case .sunny: return "â˜€ï¸"
        case .cloudy: return "â˜ï¸"
        case .rainy: return "ðŸŒ§"
        case .stormy: return "â›ˆ"
        case .snowy: return "â„ï¸"
        }
    }
    
    var description: String {
        rawValue.capitalized
    }
}`
  }
];

// AI models data with renamed "tools" to "capabilities"
const AI_MODELS = [
  { 
    name: "Phi3", 
    cost: 1000, 
    autoCodePerSecond: 5,
    quality: "low",
    capabilities: [] 
  },
  { 
    name: "Llama2", 
    cost: 10000, 
    autoCodePerSecond: 50,
    quality: "medium",
    capabilities: [] 
  },
  { 
    name: "MistralSmall", 
    cost: 20000, 
    autoCodePerSecond: 250,
    quality: "medium",
    capabilities: ["review"] 
  },
  { 
    name: "Claude 3", 
    cost: 100000, 
    autoCodePerSecond: 1000,
    quality: "high",
    capabilities: ["review", "agentic"] 
  },
  { 
    name: "Claude 3.5", 
    cost: 250000, 
    autoCodePerSecond: 1500,
    quality: "high",
    capabilities: ["review", "agentic", "reasoning"] 
  },
  { 
    name: "GPT4", 
    cost: 500000, 
    autoCodePerSecond: 2000,
    quality: "high",
    capabilities: ["image", "reasoning", "web", "review", "agentic"] 
  },
  { 
    name: "Claude 3.7", 
    cost: 2000000, 
    autoCodePerSecond: 25000,
    quality: "extreme",
    capabilities: ["review", "reasoning", "web", "agentic"] 
  },
  { 
    name: "DeepSeekR1", 
    cost: 3000000, 
    autoCodePerSecond: 20000,
    quality: "extreme",
    capabilities: ["review", "reasoning", "web", "agentic"] 
  },
  { 
    name: "Claude Code", 
    cost: 5000000, 
    autoCodePerSecond: 50000,
    quality: "extreme",
    capabilities: ["review", "reasoning", "web", "agentic", "autonomous"] 
  }
];

// Freelance task data with updated durations
const TASK_TYPES = [
  {
    id: "text-processing",
    name: "Text Processing",
    description: "Basic text formatting and correction tasks",
    unlockCost: 5000,
    minReward: 100,
    maxReward: 300,
    complexity: 1,
    timeRequired: 5, // 5 seconds
    icon: "file-text"
  },
  {
    id: "documentation",
    name: "Documentation",
    description: "Writing and updating technical documentation",
    unlockCost: 20000,
    minReward: 300,
    maxReward: 700,
    complexity: 2,
    timeRequired: 15, // 15 seconds
    icon: "book-open"
  },
  {
    id: "bug-fixing",
    name: "Bug Fixing",
    description: "Identifying and fixing bugs in existing code",
    unlockCost: 50000,
    minReward: 500,
    maxReward: 1500,
    complexity: 3,
    timeRequired: 30, // 30 seconds
    icon: "bug"
  },
  {
    id: "feature-dev",
    name: "Feature Development",
    description: "Developing new features for existing applications",
    unlockCost: 200000,
    minReward: 1000,
    maxReward: 3000,
    complexity: 4,
    timeRequired: 60, // 1 minute
    icon: "puzzle-piece"
  },
  {
    id: "project-dev",
    name: "Full Project",
    description: "Complete project development from scratch",
    unlockCost: 750000,
    minReward: 5000,
    maxReward: 12000,
    complexity: 5,
    timeRequired: 180, // 3 minutes
    icon: "code"
  },
  {
    id: "upwork-gig",
    name: "Upwork Gig",
    description: "High-value freelance contracts from Upwork",
    unlockCost: 2000000,
    minReward: 10000,
    maxReward: 50000,
    complexity: 6,
    timeRequired: 300, // 5 minutes
    icon: "briefcase"
  }
];

// AI Agent data with updated autonomy levels and prices
// Sorted in ascending order of autonomy for consistent display
const AI_AGENT_TYPES = [
  {
    id: "junior",
    name: "Junior AI Agent",
    cost: 50000,
    efficiency: 0.7,
    autonomy: 0.2,
    maxTasks: 1,
    maxCount: 10 // Cap the number of agents
  },
  {
    id: "mid",
    name: "Mid-Level AI Agent",
    cost: 200000,
    efficiency: 0.85,
    autonomy: 0.4,
    maxTasks: 2,
    maxCount: 10
  },
  {
    id: "senior",
    name: "Senior AI Agent",
    cost: 500000,
    efficiency: 1,
    autonomy: 0.6,
    maxTasks: 3,
    maxCount: 10
  },
  {
    id: "principal",
    name: "Principal AI Agent",
    cost: 1500000,
    efficiency: 1.2,
    autonomy: 0.8,
    maxTasks: 4,
    maxCount: 10
  },
  {
    id: "autonomous",
    name: "Autonomous AI Agent",
    cost: 1000000000, // 1 billion
    efficiency: 2.0,
    autonomy: 0.95,
    maxTasks: 10,
    maxCount: 10
  },
  {
    id: "superintelligent",
    name: "Superintelligent AI Agent",
    cost: 100000000000, // 100 billion
    efficiency: 5.0,
    autonomy: 0.99,
    maxTasks: 100,
    maxCount: 10
  }
];

// Quality color mapping
const QUALITY_COLORS = {
  low: "text-gray-500",
  medium: "text-blue-500",
  high: "text-purple-500",
  extreme: "text-pink-600 font-bold"
};

// Syntax highlighting function - simplistic version
const syntaxHighlight = (code, language) => {
  if (!code) return '';
  
  // Make a copy of the code to avoid modifying the original
  let highlightedCode = code;
  
  try {
    // Replace comments - do this first since they can contain other syntax elements
    highlightedCode = highlightedCode.replace(
      /(\/\/.*|\/\*[\s\S]*?\*\/|#.*)/g, 
      '<span class="text-green-500">$1</span>'
    );
    
    // Replace strings - be careful with escaped quotes
    highlightedCode = highlightedCode.replace(
      /(['"`])(?:\\\1|.)*?\1/g, 
      match => `<span class="text-yellow-300">${match}</span>`
    );
    
    // Replace numbers
    highlightedCode = highlightedCode.replace(
      /\b(\d+(?:\.\d+)?)\b/g,
      '<span class="text-purple-300">$1</span>'
    );
    
    // Replace keywords (basic list)
    const keywords = [
      'function', 'const', 'let', 'var', 'class', 'struct', 'enum', 'if', 'else', 
      'for', 'while', 'do', 'switch', 'case', 'break', 'continue', 'return', 
      'void', 'int', 'float', 'double', 'boolean', 'string', 'import', 'from', 'export',
      'fn', 'pub', 'impl', 'use', 'package', 'func', 'type', 'interface', 'defer',
      'async', 'await', 'try', 'catch', 'throw', 'new', 'this', 'super', 'static',
      'public', 'private', 'protected', 'final', 'override', 'extends', 'implements'
    ];
    
    const keywordPattern = new RegExp(`\\b(${keywords.join('|')})\\b`, 'g');
    highlightedCode = highlightedCode.replace(
      keywordPattern,
      '<span class="text-blue-400">$1</span>'
    );
    
    return highlightedCode;
  } catch (error) {
    // If any error occurs during highlighting, just return the original code
    console.error("Error highlighting code:", error);
    return code;
  }
};

const TheLastCodeGame = () => {
  // Game state
  const [codeLines, setCodeLines] = useState(0);
  const [incrementFactor, setIncrementFactor] = useState(5);
  const [money, setMoney] = useState(0);
  const [moneyTimer, setMoneyTimer] = useState(5);
  const [activeModel, setActiveModel] = useState(null);
  const [aiCodeShare, setAiCodeShare] = useState(0);
  const [showUpgradesModal, setShowUpgradesModal] = useState(false);
  const [highlightedText, setHighlightedText] = useState('');
  const [activeTab, setActiveTab] = useState("code"); // 'code' or 'management'
  const [showShortcutHelp, setShowShortcutHelp] = useState(false);
  const [managementUnlocked, setManagementUnlocked] = useState(false);
  const [isFullyAutomated, setIsFullyAutomated] = useState(false);
  const [level3Unlocked, setLevel3Unlocked] = useState(false);
  const [observationMode, setObservationMode] = useState(false);
  const [aiSharePrecision, setAiSharePrecision] = useState(2);
  const [targetAiShare, setTargetAiShare] = useState(0);
  
  // Management tab state
  const [unlockedTasks, setUnlockedTasks] = useState([TASK_TYPES[0]]);
  const [ownedAgents, setOwnedAgents] = useState([]);
  const [activeAssignments, setActiveAssignments] = useState([]);
  const [incomingTasks, setIncomingTasks] = useState([]);
  const [completedTasks, setCompletedTasks] = useState(0);
  
  // New state for verification mode
  const [agentsInVerificationMode, setAgentsInVerificationMode] = useState([]);
  
  // Code display state
  const [visibleCodeSample, setVisibleCodeSample] = useState(0);
  const [currentCodeText, setCurrentCodeText] = useState('');
  const [typingPosition, setTypingPosition] = useState(0);
  const [isAIWriting, setIsAIWriting] = useState(false);
  
  // Ref to track latest codeLines value
  const codeLinesRef = useRef(codeLines);
  const gameContainerRef = useRef(null);
  const codeRef = useRef(null);

  // Initialize code sample
  useEffect(() => {
    setCurrentCodeText('');
    setTypingPosition(0);
    updateHighlightedText('');
  }, [visibleCodeSample]);

  // Auto-scrolling for code view
  useEffect(() => {
    if (codeRef.current) {
      codeRef.current.scrollTop = codeRef.current.scrollHeight;
    }
  }, [highlightedText]);

  // Keep codeLinesRef updated with latest codeLines value
  useEffect(() => {
    codeLinesRef.current = codeLines;
  }, [codeLines]);

  // Check if observation mode should be activated
  useEffect(() => {
    if (aiCodeShare >= 90 && !observationMode) {
      setObservationMode(true);
      setTargetAiShare(99);
      setAiSharePrecision(2);
    }
  }, [aiCodeShare, observationMode]);
  
  // Handle observation mode animation
  useEffect(() => {
    if (!observationMode) return;
    
    const animationSteps = {
      1: { target: 99, precision: 2, duration: 7000 },
      2: { target: 99.9, precision: 3, duration: 7000 },
      3: { target: 99.99, precision: 4, duration: 6000 },
      4: { target: 99.999, precision: 5, duration: 4000 },
      5: { target: 99.9999, precision: 6, duration: 3000 },
      6: { target: 99.99999, precision: 7, duration: 3000 }
    };
    
    let currentStep = 1;
    let timer;
    
    const runAnimation = () => {
      if (!animationSteps[currentStep]) return;
      
      const { target, precision, duration } = animationSteps[currentStep];
      setTargetAiShare(target);
      setAiSharePrecision(precision);
      
      // Gradually increase AI share to target
      const startValue = aiCodeShare;
      const startTime = Date.now();
      
      const update = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Use easeOut for smoother animation at the end
        const easeOutProgress = 1 - Math.pow(1 - progress, 3);
        
        const newValue = startValue + (target - startValue) * easeOutProgress;
        setAiCodeShare(newValue);
        
        if (progress < 1) {
          timer = requestAnimationFrame(update);
        } else {
          // Move to next step
          currentStep++;
          if (animationSteps[currentStep]) {
            setTimeout(runAnimation, 1000); // Pause between steps
          }
        }
      };
      
      timer = requestAnimationFrame(update);
    };
    
    runAnimation();
    
    return () => {
      if (timer) cancelAnimationFrame(timer);
    };
  }, [observationMode]);

  // Check if management tab should be unlocked
  useEffect(() => {
    if (activeModel && 
        activeModel.capabilities.includes('agentic') && 
        !managementUnlocked) {
      setManagementUnlocked(true);
    }
  }, [activeModel, managementUnlocked]);
  
  // Check for automation when purchasing high-level agents
  useEffect(() => {
    // Check if the player has any fully autonomous agents
    const hasAutonomousAgent = ownedAgents.some(agent => {
      const agentType = getAgentType(agent.type);
      return agentType.autonomy >= 0.95;
    });
    
    if (hasAutonomousAgent && !isFullyAutomated) {
      setIsFullyAutomated(true);
    }
    
    // Check for level 3 unlock
    const hasSuperAgent = ownedAgents.some(agent => {
      const agentType = getAgentType(agent.type);
      return agentType.autonomy >= 0.99;
    });
    
    if (hasSuperAgent && !level3Unlocked) {
      setLevel3Unlocked(true);
    }
  }, [ownedAgents]);

  // Auto-run tasks when in fully automated mode
  useEffect(() => {
    if (!isFullyAutomated) return;
    
    const automationInterval = setInterval(() => {
      // Auto-assign tasks to available agents
      const availableAgents = getAvailableAgents();
      const pendingTasks = [...incomingTasks];
      
      if (availableAgents.length > 0 && pendingTasks.length > 0) {
        // Sort agents by efficiency
        const sortedAgents = [...availableAgents].sort((a, b) => {
          const aType = getAgentType(a.type);
          const bType = getAgentType(b.type);
          return bType.efficiency - aType.efficiency;
        });
        
        // Assign tasks optimally
        sortedAgents.forEach(agent => {
          if (pendingTasks.length > 0) {
            const task = pendingTasks.shift();
            assignTask(task, agent);
          }
        });
      }
      
      // Auto-purchase new agents if money allows
      if (ownedAgents.length < 10) { // Limit to 10 agents
        // Find the most expensive agent the player can afford
        const affordableAgents = AI_AGENT_TYPES.filter(agent => 
          agent.cost <= money && 
          getAgentCount(agent.id) < agent.maxCount // Check against max count per agent type
        );
        
        if (affordableAgents.length > 0) {
          // Sort by cost descending
          const sortedAgents = [...affordableAgents].sort((a, b) => b.cost - a.cost);
          purchaseAgent(sortedAgents[0]);
        }
      }
      
      // Auto-unlock new task types
      TASK_TYPES.forEach(taskType => {
        if (money >= taskType.unlockCost && 
            !unlockedTasks.some(t => t.id === taskType.id)) {
          unlockTaskType(taskType);
        }
      });
    }, 2000); // Run automation every 2 seconds
    
    return () => clearInterval(automationInterval);
  }, [isFullyAutomated, incomingTasks, ownedAgents, money, unlockedTasks]);

  // Handle auto-verification from high-autonomy agents
  useEffect(() => {
    if (agentsInVerificationMode.length === 0) return;
    
    const verificationInterval = setInterval(() => {
      // Get all assignments needing verification
      const pendingVerifications = activeAssignments.filter(
        assignment => assignment.status === "pending-verification"
      );
      
      if (pendingVerifications.length > 0) {
        // Auto-verify each task, simulating a 1s verification time
        pendingVerifications.forEach(assignment => {
          verifyTask(assignment.id);
        });
      }
    }, 1000); // Check every second
    
    return () => clearInterval(verificationInterval);
  }, [agentsInVerificationMode, activeAssignments]);

  // Keyboard shortcuts with new additions
  useEffect(() => {
    const handleKeyDown = (e) => {
      // Don't trigger shortcuts if user is typing in an input
      if (e.target.tagName === 'INPUT' || 
          e.target.tagName === 'TEXTAREA' || 
          e.target.tagName === 'SELECT') {
        return;
      }
      
      // Close modal with Escape key
      if (e.key === 'Escape') {
        if (showUpgradesModal) {
          setShowUpgradesModal(false);
          return;
        }
      }
      
      // Debug button shortcut (D key) - works in any tab
      if (e.key === 'd' || e.key === 'D') {
        e.preventDefault();
        setMoney(prev => prev + 10000000000); // Add 10 billion
        return;
      }

      switch (activeTab) {
        case 'code':
          switch (e.key) {
            case ' ': // Spacebar
              e.preventDefault(); // Prevent page scroll
              writeCode();
              break;
            case 'r':
            case 'R':
              if (codeLines >= 20) refactorCode();
              break;
            case 'u':
            case 'U':
              setShowUpgradesModal(!showUpgradesModal);
              break;
            case 'm':
            case 'M':
              if (managementUnlocked) setActiveTab('management');
              break;
            case '?':
              setShowShortcutHelp(prev => !prev);
              break;
            default:
              // Numeric keys for purchasing upgrades
              if (showUpgradesModal && /^[1-9]$/.test(e.key)) {
                const modelIndex = parseInt(e.key) - 1;
                if (modelIndex >= 0 && modelIndex < AI_MODELS.length) {
                  const model = AI_MODELS[modelIndex];
                  if (money >= model.cost && activeModel?.name !== model.name) {
                    purchaseModel(model);
                  }
                }
              }
              break;
          }
          break;
          
        case 'management':
          switch (e.key) {
            case 'c':
            case 'C':
              setActiveTab('code');
              break;
            case '?':
              setShowShortcutHelp(prev => !prev);
              break;
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              // Quick assign task to agent by number (extended to 9 agents)
              if (incomingTasks.length > 0 && ownedAgents.length >= parseInt(e.key)) {
                const agentIndex = parseInt(e.key) - 1;
                const agent = ownedAgents[agentIndex];
                const task = incomingTasks[0];
                
                if (agent && task && agent.currentTasks < getAgentType(agent.type).maxTasks) {
                  assignTask(task, agent);
                }
              }
              break;
            default:
              break;
          }
          break;
          
        default:
          break;
      }
    };

    // Add event listener
    window.addEventListener('keydown', handleKeyDown);
    
    // Remove event listener on cleanup
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [
    activeTab, 
    codeLines, 
    showUpgradesModal, 
    incomingTasks, 
    ownedAgents, 
    managementUnlocked, 
    money, 
    activeModel
  ]);